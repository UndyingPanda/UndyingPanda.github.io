---
title: ICS 第10章 系统级I/O
tags: course,ics
date: 2025-09-24 13:00:00
---
.代表当前目录，而..代表上级目录（也即当前目录的父目录）
截断文件意味着删除文件的内容并将其大小设置为0。
通过带某个mod参数的open函数调用创建一个新文件时，文件的访问权限位被设置为`mode & ~umask`，umask函数可以设置umask，它作为上下文的一部分，每个进程都有一个umask。
带缓冲的函数rio_readlineb和rio_readnb不应该和无缓冲的函数rio_readn交叉使用！

`opendir`函数返回的目录流指针 dir 是一个指向目录的内部状态的指针。每次调用 readdir(dir) 时，目录流会向前“推进”，即返回下一个目录项的信息。(相当于一个迭代器)

```c
#include <fcntl.h>
#include <unistd.h>

int open(const char *pathname, int flags, mode_t mode);

```
第一个参数是要打开的文件的路径。它可以是绝对路径（例如 /home/user/file.txt）或者相对路径（例如 file.txt）。第二个参数是文件打开的标志（控制文件的访问模式和行为）。它是一个位掩码，可以使用按位或（|）来组合多个标志。
而第三个参数mode是可选的：如果文件是新创建的，并且没有写入权限，则此参数指定文件的权限。它是一个八进制数，仅在文件创建时有效。(也即flags参数中含有O_CREAT：如果文件不存在，则创建新文件。此时需要提供 mode 参数指定权限。)

在fork时，子进程也会复制父进程的流缓冲区。（可能会把父进程没有输出完，但是还在流缓冲区的内容重复输出）

不要使用scanf或rio_readlineb来读二进制文件，因为二进制文件中可能存在很多0xa，它们实际上并不是换行符，会导致函数的行为异常。

## 两个限制
限制一：跟在输出函数之后的输入函数
当你执行一个输出函数后，流的缓冲区中可能还有未被写入的内容。若紧接着调用输入函数，输入函数无法判断缓冲区是否已经完全刷新到文件中。标准 I/O 流在执行输入操作时，期望缓冲区已经清空，这样才能正确读取数据。如果没有显式地使用 fflush 函数来刷新缓冲区，流中的内容可能会被遗漏或无法正确同步，从而导致错误的读取结果。

为什么需要 fflush？ fflush 会强制刷新缓冲区中的内容，使得所有待输出的数据立即被写入目标位置。这样，当后续执行输入操作时，输入函数可以确保流的状态是正确的，不会出现已写入的数据被“覆盖”或“丢失”的问题。

限制二：跟在输入函数之后的输出函数
与第一个限制类似，输入函数通常会消耗流中的数据，并且可能会移动文件指针（例如读取文件时，文件指针会从当前位置向后移动）。如果在输入操作之后直接调用输出操作，流的状态和文件指针的位置可能已经发生了变化，导致输出操作无法从预期的位置开始写入，甚至可能出现覆盖现有数据的情况。

为什么需要 fseek、fsetpos 或 rewind？ 这些函数可以修改文件指针的位置，保证后续的输出操作能够正确地定位到文件中的合适位置。通过调用这些函数，你可以确保文件指针正确地指向你想要输出数据的位置，避免数据丢失或错乱。

`1.描述符表`: 每个进程都有自己的描述符表
`2.打开文件表`: 所有进程共享，open创建，通过refcnt来管理回收，通过fork和dup来改变打开文件表中的表项内容。
`status`,`pos`,`refcnt`,`vnode_ptr`.
pos指明当前对该文件的操作行为。
`3.v-node表`: 所有进程共享，可以看成某个磁盘文件。
与某个磁盘文件进行绑定。

每次open会在open file table中创建一个表项。这个时候pos会恢复为0。被多少个文件描述符指着的open file table的refcnt就为几。而v-node表中每个表项的refcnt就是它被open file table中的多少个表项指着。

每次close一个文件描述符，都会在open file table中将对应的open file table表项的refcnt减1，一但refcnt=0，则会回收，接着把v-node表项中相应的表项中的refcnt减1。v-node中的某个表项的refcnt为0的时候，也会导致其被回收。

fork子进程后，会导致open file table相关条目refcnt增加，注意，这个时候其实大家的pos相同。多个进程可以共享对同一个文件的处理。

注意dup2传入参数的顺序:
```c
dup2(fd1,fd2);
```
这个时候会使得fd1指向的东西赋值给fd2。
或者说让fd2也指向fd1指向的东西。

printf是带有缓冲区的。（意味着需要加锁）。
printf = fprint + (FILE*)stdout
freopen?
User buffer也是用来平衡系统调用开销。

标准I/O缓冲区刷新时间：buffer满了；close；exit() （这里注意_exit()不刷新缓冲区，故可以用在signal_handler）;main return 0 这个等价于exit；换行符/n（此时强制刷新缓冲区）；fflush(stdout) 立即刷新缓冲区。
read, write无缓冲区。

每个进程的缓冲区是独立的，缓冲区会被fork继承。
SIGSTOP中的进程只能处理SIGCONT和SIGKILL信号，即使来了SIGINT也不会立即处理，只会阻塞等待SIGCONT唤醒。

一级页表的物理地址存在Cr3中。物理页面是不连续的，便于调度和管理。页表由操作系统维护，user不能修改，每个进程的页表是独立的，user不能直接访问物理地址。
可以隔离不同进程/kernel。
虚拟内存可以帮助设置权限位，比如代码段我希望是只读的，则指向代码段的页表的权限是只读，不能进行修改。


